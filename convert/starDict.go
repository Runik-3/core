package convert

import (
	"encoding/binary"
	"fmt"
	"os"
	"path/filepath"
	"text/template"

	"github.com/runik-3/core/core"
)

type ifoData struct {
	Name        string
	Wordcount   int
	Idxfilesize int
}

const IFO_TEMPLATE string = `StarDict's dict ifo file
version=3.0.0
bookname={{.Name}}
wordcount={{.Wordcount}}
idxfilesize={{.Idxfilesize}}
sametypesequence=h
description=Dictionary generated by runik https://runik.app`

// Convert to the stardict dictionary format
// https://stardict-4.sourceforge.net/StarDictFileFormat
func StarDict(dictPath string, outDir string, appConfigDir string) error {
	dictionary, err := core.DictFromFile(dictPath)
	if err != nil {
		return err
	}

	// Create the containing folder
	dictContainer := filepath.Join(outDir, dictionary.Name)
	err = os.MkdirAll(dictContainer, os.ModePerm)
	if err != nil {
		return err
	}

	// Process dict entries
	dictByteIndex := 0

	dict, err := os.Create(filepath.Join(dictContainer, fmt.Sprintf("%s.dict", dictionary.Name)))
	if err != nil {
		return err
	}

	idxByteSequence := []byte{}
	for _, entry := range dictionary.Lexicon {
		size, err := dict.Write(fmt.Appendf(nil, "<p>%s</p>", entry.Definition))
		if err != nil {
			return err
		}

		// [word][00][dict article offset 4-bytes][dict article size 4-bytes]
		idxByteSequence = append(idxByteSequence, []byte(entry.Word)...)
		idxByteSequence = append(idxByteSequence, 0)                                            // zero-terminate
		idxByteSequence = binary.BigEndian.AppendUint32(idxByteSequence, uint32(dictByteIndex)) // encode article offset
		idxByteSequence = binary.BigEndian.AppendUint32(idxByteSequence, uint32(size))          // encode article size

		dictByteIndex += size
	}

	idx, err := os.Create(filepath.Join(dictContainer, fmt.Sprintf("%s.idx", dictionary.Name)))
	if err != nil {
		return err
	}

	// write idx
	_, err = idx.Write(idxByteSequence)
	if err != nil {
		return err
	}

	// write ifo file
	ifo, err := os.Create(filepath.Join(dictContainer, fmt.Sprintf("%s.ifo", dictionary.Name)))
	if err != nil {
		return err
	}

	// TODO: create syn file when we have support for synonyms

	ifoTmpl, err := template.New("ifo").Parse(IFO_TEMPLATE)
	if err != nil {
		return err
	}

	err = ifoTmpl.Execute(ifo, ifoData{
		Name:        dictionary.Name,
		Wordcount:   len(dictionary.Lexicon),
		Idxfilesize: len(idxByteSequence),
	})
	if err != nil {
		return err
	}

	return nil
}
